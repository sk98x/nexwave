ADDITION :

SQL> DECLARE
  2  NUM1 NUMBER(2);
  3  NUM2 NUMBER(2);
  4  BEGIN
  5  DBMS_OUTPUT.PUT_LINE(&NUM1+&NUM2);
  6  END;
  7  /
Enter value for num1: 50
Enter value for num2: 23
old   5: DBMS_OUTPUT.PUT_LINE(&NUM1+&NUM2);
new   5: DBMS_OUTPUT.PUT_LINE(50+23);
73

PL/SQL procedure successfully completed.



FETCHING RECORDS AT RUNTIME:

SQL> SELECT &COL1,&COL2 FROM EMP WHERE &COND;
Enter value for col1: EMPNO
Enter value for col2: ENAME
Enter value for cond: DEPTNO=30
old   1: SELECT &COL1,&COL2 FROM EMP WHERE &COND
new   1: SELECT EMPNO,ENAME FROM EMP WHERE DEPTNO=30

     EMPNO ENAME
---------- ----------
      7499 ALLEN
      7521 WARD
      7654 MARTIN
      7698 BLAKE
      7844 TURNER
      7900 JAMES

6 rows selected.


SQL> DECLARE
  2  V_NAME EMP.ENAME%TYPE;
  3  V_EMPNO EMP.EMPNO%TYPE;
  4  V_SALARY EMP.SAL%TYPE;
  5  V_MANAGER EMP.MGR%TYPE;
  6  BEGIN
  7  SELECT EMPNO,ENAME,SAL,MGR INTO V_EMPNO,V_NAME,V_SALARY,V_MANAGER FROM EMP WHERE EMPNO=7369;
  8  DBMS_OUTPUT.PUT_LINE(CHR(10)||'EMPLOYEE NUMBER: '||V_EMPNO||CHR(10)||'EMPLOYEE NAME: '||V_NAME||CHR(10)||'EMPLOYEE MANAGER : '||V_MANAGER||CHR(10)||'EMPLOYEE SALARY: '||V_SALARY);
  9
 10  END;
 11  /

EMPLOYEE NUMBER: 7369
EMPLOYEE NAME: SMITH
EMPLOYEE MANAGER : 7902
EMPLOYEE SALARY: 800

PL/SQL procedure successfully completed.


BIND VARIABLES:

SQL> VARIABLE SUM NUMBER
SQL> DECLARE
  2  NUM1 NUMBER:=20;
  3  NUM2 NUMBER:=30;
  4  BEGIN
  5  :SUM:=NUM1+NUM2;
  6  DBMS_OUTPUT.PUT_LINE(:SUM);
  7  END;
  8  /
50

PL/SQL procedure successfully completed.

SQL> PRINT SUM

       SUM
----------
        50



SEQUENCE :

SQL> CREATE SEQUENCE SE START WITH 10 INCREMENT BY 2 MAXVALUE 20;

Sequence created.


SQL> DECLARE
  2  VID NUMBER;
  3  BEGIN
  4  VID:=SE.NEXTVAL;
  5  DBMS_OUTPUT.PUT_LINE(VID);
  6  END;
  7  /
10


SQL> BEGIN <<OUTER>>
  2  DECLARE
  3  VAR NUMBER:=10;
  4  BEGIN
  5  DECLARE
  6  VAR NUMBER:=20;
  7  BEGIN
  8  DBMS_OUTPUT.PUT_LINE('INNER VALUE: '||VAR||CHR(10)||'OUTER VALUE: '||OUTER.VAR);
  9  END;
 10  END;
 11  END OUTER;
 12  /
INNER VALUE: 20
OUTER VALUE: 10

PL/SQL procedure successfully completed.



IF-ELSIF-ELSE:

SQL> DECLARE
  2  MRK NUMBER:=&MRK;
  3  BEGIN
  4  IF MRK>90 THEN
  5  DBMS_OUTPUT.PUT_LINE('GRADE A');
  6  ELSIF MRK>80 THEN
  7  DBMS_OUTPUT.PUT_LINE('GRADE B');
  8  ELSIF MRK>70 THEN
  9  DBMS_OUTPUT.PUT_LINE('GRADE C');
 10  ELSIF MRK>60 THEN
 11  DBMS_OUTPUT.PUT_LINE('GRADE D');
 12  ELSIF MRK>50 THEN
 13  DBMS_OUTPUT.PUT_LINE('GRADE E');
 14  ELSE
 15  DBMS_OUTPUT.PUT_LINE('GRADE F');
 16  END IF;
 17  END;
 18  /
Enter value for mrk: 56
old   2: MRK NUMBER:=&MRK;
new   2: MRK NUMBER:=56;
GRADE E

PL/SQL procedure successfully completed.

LOOP:
SQL> DECLARE
  2  I NUMBER(2):=1;
  3  BEGIN
  4  LOOP
  5  DBMS_OUTPUT.PUT_LINE(I);
  6  I:=I+1;
  7  EXIT WHEN I>10;
  8  END LOOP;
  9  END;
 10  /
1
2
3
4
5
6
7
8
9
10


FOR LOOP:

SQL> 
  2  BEGIN
  3  FOR I IN 1..10 LOOP
  4  DBMS_OUTPUT.PUT_LINE(I);
  5  END LOOP;
  6  END;
  7  /
1
2
3
4
5
6
7
8
9
10


WHILE LOOP:

SQL> DECLARE
  2  I NUMBER(2):=1;
  3  BEGIN
  4  WHILE I<10 LOOP
  5  DBMS_OUTPUT.PUT_LINE(I);
  6  I:=I+1;
  7  END LOOP;
  8  END;
  9  /
1
2
3
4
5
6
7
8
9

PL/SQL procedure successfully completed.



SQL> DECLARE
  2  J NUMBER(2):=1;
  3  BEGIN
  4  FOR I IN 1..5 LOOP
  5  J:=1;
  6  WHILE J<=I LOOP
  7  DBMS_OUTPUT.PUT('*');
  8  J:=J+1;
  9  END LOOP;
 10  DBMS_OUTPUT.PUT_LINE('');
 11  END LOOP;
 12  END;
 13  /
*
**
***
****
*****

PL/SQL procedure successfully completed.


CURSORS:	

SQL> DECLARE
  2  CURSOR CUR IS SELECT ENAME,SAL FROM EMP WHERE DEPTNO=10;
  3  V_NAME EMP.ENAME%TYPE;
  4  V_SAL EMP.SAL%TYPE;
  5  BEGIN
  6  OPEN CUR;
  7  LOOP
  8  FETCH CUR INTO V_NAME,V_SAL;
  9  EXIT WHEN CUR%NOTFOUND;
 10  DBMS_OUTPUT.PUT_LINE(V_NAME||' '||V_SAL);
 11  END LOOP;
 12  END;
 13  /
CLARK 2450
KING 5000
MILLER 1300



SQL> DECLARE
  2  CURSOR CUR IS SELECT * FROM EMP;
  3  BEGIN
  4  FOR I IN CUR LOOP
  5  DBMS_OUTPUT.PUT_LINE(I.ENAME||I.EMPNO);
  6  END LOOP;
  7  END;
  8  /
SMITH7369
ALLEN7499
WARD7521
JONES7566
MARTIN7654
BLAKE7698
CLARK7782
SCOTT7788
KING7839
TURNER7844
ADAMS7876
JAMES7900
FORD7902
MILLER7934

PL/SQL procedure successfully completed.


GETTING RECORDS WITHOUT CURSOR:

SQL> BEGIN
  2  FOR I IN (SELECT * FROM EMP)
  3  LOOP
  4  DBMS_OUTPUT.PUT_LINE(I.ENAME||I.EMPNO);
  5  END LOOP;
  6  END;
  7  /
SMITH7369
ALLEN7499
WARD7521
JONES7566
MARTIN7654
BLAKE7698
CLARK7782
SCOTT7788
KING7839
TURNER7844
ADAMS7876
JAMES7900
FORD7902
MILLER7934

PL/SQL procedure successfully completed.

EXCEPTION HANDLING:

DECLARE
ESCA EMP%ROWTYPE;
BEGIN
SELECT * INTO ESCA FROM EMP WHERE EMPNO=&EMP;
DBMS_OUTPUT.PUT_LINE('EMPLOYEE NAME :'||ESCA.ENAME);
EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('NO DATA FOUND!!');
END;

Enter value for emp: 323
old   4: SELECT * INTO ESCA FROM EMP WHERE EMPNO=&EMP;
new   4: SELECT * INTO ESCA FROM EMP WHERE EMPNO=323;
NO DATA FOUND!!


SQL> DECLARE
  2  EXP EXCEPTION;
  3  PRAGMA EXCEPTION_INIT(EXP,-01400);
  4  BEGIN
  5  INSERT INTO DEPT VALUES(null,'','');
  6  EXCEPTION
  7  WHEN EXP THEN
  8  DBMS_OUTPUT.PUT_LINE('PRIMARY KEY CANNOT BE NULL '||SQLERRM);
  9  END;
 10  /
PRIMARY KEY CANNOT BE NULL ORA-01400: cannot insert NULL into ("SCOTT"."DEPT"."DEPTNO")

PL/SQL procedure successfully completed.
